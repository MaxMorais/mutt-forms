<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: form.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: form.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
* @file Main Pug interface
* @copyright Bought By Many 2016
*/

'use strict';

import {buildForm} from './builder';

export default class Pug {

    /**
    * Initialisation of a Pug form
    * @constructor
    * @param {HTMLElement} container Containing element for the Pug Form
    * @param {object} schema JSON Schema containing Form &amp; Field Configuration
    * @param {object} options optional form configuration options
    * @param {function} callback optional callback for form submission
    * @param {boolean} debug debugging flag
    */
    constructor(container, schema, options = null, callback = null, 
        debug = false) {

        this.container = container;
        this.mulipart = false;
        this.callback = callback;
        this.id = null;
        this.debug = debug;
        this.locked = false;

        this.form = null;
        this.fieldsets = [];
        this.options = {};

        if(options.hasOwnProperty('form')) {
            this.options = options.form;
        }

        // Build the form from the config
        this.build(schema, options);
    }

    /**
    * Build the form from the config
    * @param {object} JSON schema of form
    * @param {object} Optional options object for the form
    */
    build(schema, options = null) {
        let fieldset = buildForm(schema, options);
        this.fieldsets.push(fieldset);
    }

    /**
    * Get the data from the form
    * @returns {object} data object for the form
    */
    data() {
        let data = [];

        for(let fieldset of this.fieldsets) {
            data.push(fieldset.data());
        }

        // TODO: Yuck - fix.
        if(data.length == 1) {
            return data[0];
        }

        return data;
    }

    /**
    * Render the form
    * @returns {promise} a promise to be resolved once rendering 
    * is complete
    */
    render() {
        return new Promise((fulfill, reject) => {
            let formContainer = document.createDocumentFragment();
            this.form = document.createElement('form');

            if(this.id) {
                this.form.setAttribute('id', this.id);
            }

            this.form.setAttribute('method', 'POST');
            this.form.setAttribute('action', '');
            this.form.setAttribute('class', 'pug-form');

            if(this.mulipart) {
                this.form.setAttribute('enctype', 'multipart/form-data');
            }

            for(let fieldset of this.fieldsets) {
                let fieldsetElement = fieldset.render();
                this.form.appendChild(fieldsetElement);
            }

            // Add form controls
            let buttonClass = 'pug-button';
            let buttonText = 'Submit';

            // Check for button overide options
            if(this.options.hasOwnProperty('buttons')) {
                if(this.options.buttons.hasOwnProperty('class')) {
                    buttonClass = buttonClass + ' ' + this.options.buttons.class;
                }

                if(this.options.buttons.hasOwnProperty('text')) {
                    buttonText = this.options.buttons.text;
                }
            }

            let buttonWrapper = document.createElement('div');
            buttonWrapper.setAttribute('class', 'pug-button-wrapper');

            let button = document.createElement('button');
            button.setAttribute('class', buttonClass);
            button.setAttribute('type', 'submit');
            button.textContent = buttonText;
            button.onclick = () => {
                this.submit();
                return false;
            };

            buttonWrapper.appendChild(button);
            this.form.appendChild(buttonWrapper);

            // Build the form and render to the viewport
            formContainer.appendChild(this.form);
            this.container.appendChild(formContainer);

            // Form has been renderd to the stage, call
            // the post render hooks
            for(let fieldset of this.fieldsets) {
                fieldset.postRender();
            }

            fulfill(this);
        });
    }

    /**
    * Validate the form
    * @returns {bool} response to the validation request
    */
    validate() {
        this.refreshValidationState();

        let valid = true;
        let errors = [];

        for(let fieldset of this.fieldsets) {
            if(!fieldset.validate()) {
                errors.push(fieldset.errors);
                valid = false;
            }
        }

        this.log(
            `Validation Complete -> Status: ${valid} -> ${JSON.stringify(errors)}`
        );

        return valid;
    }

    /**
    * Redraw all of the error states on the stage
    */
    refreshValidationState() {
        for(let fieldset of this.fieldsets) {
            fieldset.refreshValidationState();
        }
    }

    /**
    * Submit handler for the form
    * @returns {bool} success or failure of submission
    */
    submit() {
        // We always validate prior to validateion
        let valid = this.validate();

        if(valid) {
            this.log('Submit form');

            if(this.callback) {
                this.callback(this.data());
            }
            else {
                this.form.submit();
            }

            return true;
        }

        return false;
    }

    /**
    * Lock a form, this changes all of the fields to a read only state
    */
    lock() {
        this.log('Locking form');

        for(let fieldset of this.fieldsets) {
            fieldset.lock();
        }
    }

    /**
    * Unlock a form, this can be used to restore a locked form to it's
    * editable state
    */
    unlock() {
        this.log('Unlocking form');

        for(let fieldset of this.fieldsets) {
            fieldset.unlock();
        }
    }

    /**
    * Set the ID for the form - this is used for rendering
    * @param {string} ID for a form
    */
    setFormId(formId) {
        this.id = formId;
    }

    /*
    * Set field errors in bulk, this is typically used to
    * show errors from a server side response
    * @param {object} a hash of errors
    */
    setFieldErrors(errors) {
        // TODO: Known limitation. Errors are not provided
        // in a hierarchical manner. Just as key/value - so
        // duplicate keys scoped by parent objects are not
        // supported. Errors are added to both fields in this
        // instance.
        for(let fieldset of this.fieldsets) {
            fieldset.setFieldErrors(errors);
        }
    }

    /**
    * Log a message
    * @param {string} Message to log
    */
    log(message) {
        if(this.debug) {
            window.console.log('Pug ->', message);
        }
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ArrayField.html">ArrayField</a></li><li><a href="ArrayInput.html">ArrayInput</a></li><li><a href="BaseChoiceWidget.html">BaseChoiceWidget</a></li><li><a href="BooleanRequiredValidator.html">BooleanRequiredValidator</a></li><li><a href="CheckboxInput.html">CheckboxInput</a></li><li><a href="DatePickerInput.html">DatePickerInput</a></li><li><a href="Field.html">Field</a></li><li><a href="Fieldset.html">Fieldset</a></li><li><a href="IntegerValidator.html">IntegerValidator</a></li><li><a href="LengthValidator.html">LengthValidator</a></li><li><a href="module.exports.html">exports</a></li><li><a href="NaturalDatePickerInput.html">NaturalDatePickerInput</a></li><li><a href="NaturalRadioInput.html">NaturalRadioInput</a></li><li><a href="NaturalSelectInput.html">NaturalSelectInput</a></li><li><a href="NaturalTextAutoCompleteInput.html">NaturalTextAutoCompleteInput</a></li><li><a href="NaturalTextInput.html">NaturalTextInput</a></li><li><a href="NumberInput.html">NumberInput</a></li><li><a href="ObjectInput.html">ObjectInput</a></li><li><a href="PCAInput.html">PCAInput</a></li><li><a href="PugRegistry.html">PugRegistry</a></li><li><a href="RadioInput.html">RadioInput</a></li><li><a href="RequiredValidator.html">RequiredValidator</a></li><li><a href="SelectInput.html">SelectInput</a></li><li><a href="TextAutoCompleteInput.html">TextAutoCompleteInput</a></li><li><a href="Validator.html">Validator</a></li><li><a href="Widget.html">Widget</a></li></ul><h3>Namespaces</h3><ul><li><a href="Widgets.html">Widgets</a></li></ul><h3>Mixins</h3><ul><li><a href="NaturalMixin.html">NaturalMixin</a></li></ul><h3>Global</h3><ul><li><a href="global.html#build">build</a></li><li><a href="global.html#data">data</a></li><li><a href="global.html#displayReadonlyValue">displayReadonlyValue</a></li><li><a href="global.html#lock">lock</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#mixin">mixin</a></li><li><a href="global.html#refreshValidationState">refreshValidationState</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#setFormId">setFormId</a></li><li><a href="global.html#submit">submit</a></li><li><a href="global.html#unlock">unlock</a></li><li><a href="global.html#validate">validate</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Tue Oct 18 2016 21:43:38 GMT+0100 (BST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
